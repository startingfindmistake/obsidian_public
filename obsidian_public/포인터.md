#포인터, #주소연산자, #간접_참조_연산자, #[[포인터 완전 정복]]
![](links/Pasted%20image%2020250521144200.png)
![[Pasted image 20250522222353.png]]
<br>
<br>
<br>

## 메모리의 주소

int형 변수`a` 가 메모리 100번지부터 할당되었다면 100번지부터 103번지까지 4바이트에 걸쳐 할당됩니다.
변수 선언 이후에는 4바이트 전체를 a라는 이름으로 사용합니다.
```c
int a;
```

<br>
<br>
<br>
<br>




## 주소 연산자: &

- 변수가 할당된 메모리 공간의 시작 주소를 의미한다
- 시작 주소를 알면 그 위치부터 변수의 크기만큼 메모리를 사용할 수 있다.

```c
#include <stdio.h>

int main(void)

{

    int a;         // int형 변수 선언

    double b;      // double형 변수 선언

    char c;        // char형 변수 선언

  

    printf("int형 변수의 주소 : %u\n", &a);     // 주소 연산자로 주소 계산

    printf("double형 변수의 주소 : %u\n", &b);

    printf("char형 변수의 주소 : %u\n", &c);

  

    return 0;

}
```


## 포인터와 간접 참조 연산자: *

- 포인터는 주소를 저장하는 변수로 일반 변수와 마찬가지로 선언 후에 사용

**포인터의 선언과 사용**
```c
#include <stdio.h>

  

int main(void)

{

    int a;             // 일반 변수 선언

    int *pa;          // 포인터 선언

  

    pa = &a;          // 포인터에 a의 주소 대입

    *pa = 10;         // 포인터로 변수 a에 10대입

  

    printf("포인터로 a값 출력 : %d\n", *pa);

    printf("변수명으로 a 값 출력 : %d\n", a);   // 변수 a 값 출력

  

    return 0;    

}
```
<br>
<br>
<br>
<br>


```c
*pa == a          //같다
```
`*pa`는 변수`a`의 쓰임과 마찬가지로 대입 연산자(=)를 기준으로
- 왼쪽에 올 때는 `pa`가 가리키는 변수의 저장 공간 **l-value**으로 사용
- 오른쪽에 올 때는 `pa`가 가리키는 변수의 값 **R-value** 으로 사용된다.




**포인터를 사용한 두 정수의 합과 평균 계산**
```c
#include <stdio.h>

  

int main(void)

{

    int a = 10, b = 15, total;      // 변수 선언과 초기화

    double avg;                     // 평균을 저장할 변수

    int *pa, *pb;                   // 포인터 동시 선언

    int *pt = &total;               // 포인터 선언과 초기화

    double *pg = &avg;             // double형 포인터 선언과 초기화

  

    pa = &a;                        // 포인터 pa에 변수 a의 줏 대입

    pb = &b;                        // 포인터 pb에 변수 b의 주소 대입

  

    *pt = *pa + *pb;                // a 값과 b 값을 더해 total에 저장

    *pg = *pt / 2.0;                // total 값을 2로 나눈 값을 avg에 저장

  

    printf("두 정수의 값: %d, %d\n", *pa, *pb);         // a의 값과 b 값 출력

    printf("두 정수의 합: %d\n", *pt);                 // total 값 출력

    printf("두 정수의 평균: %.1f\n", *pg);             // avg 값 출력

  

    return 0;

}
```
<br>
<br>
<br>
<br>
<br>
<br>


## const를 사용한 포인터
* const 예약어를 포인터에 사용하면 이는 가리키는 변수의 값을 바꿀수 없다는 의미로, 변수에 사용하는 것과 다른 의미를 가집니다.

```c
#include <stdio.h>

  

int main(void)

{

    int a = 10, b = 20;

    const int *pa = &a;          //포인터 pa는 변수 a를 가리킨다.

  

    printf("변수 a의 값: %d\n", *pa);   // 포인터를 간접 참조하여 a 출력

    pa = &b;                           //포인터가 변수 b를 가리키게 한다..

    printf("변수 b의 값: %d\n", *pa);   // 포인터를 간접 참조하여 b 값 출력

    pa = &a;                           // 포인터가 다시 변수 a를 가리킨다.

    a = 20;                            // a를 직접 참조하여 값을 바꾼다.

    printf("변수 a의 값: %d\n", *pa);   // 포인터로 간접 참조하여 바뀐 값 출력

    return 0;

}
```
<br>

```bash
변수 a의 값: 10
변수 b의 값: 20
변수 a의 값: 20
```
위의 실행결과는 값이 바뀌어서 잘 나온다

포인터에 사용된 const의 의미는 무엇일까?
- **바로 `pa`가 가리키는 변수 `a`는 `pa`를 간접 참조하여 바꿀 수 없다는 것입니다.**
<br>
만약 12행에서 `*pa=20;`과 같이 `pa`를 통해 `a`값을 바꾸고자 한다면

```bash
error C2166: l-value가 const 개체를 지정합니다.
```
라는 오류가 발생한다.
<br>
<br>
**포인터에 const를 사용하는 이유**
변수 a는 어디까지나 포인터를 통해서만 바꿀 수 없으며 변수 a 자체를 사용하면 얼마든지 바꿀 수 있습니다.
- 포인터에 const를 사용하는 대표적인 예는 문자열 상수를 인수로 받는 함수 입니다
	- 문자열 상수는 값이 바뀌면 안 되는 저장 공간이므로 함수의 매개변수를 통해서 값을 바꿀 수 없도록 매개변수로 선언된 포인터에 const를 사용합니다.

